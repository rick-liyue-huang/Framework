<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
    <style>
        div {
            width: 400px;
            height: 50px;
            margin: 10px 0;
        }
        .c {
            border: 1px solid red;
        }
        .c1 {
            border: 1px solid blue;
        }
        .c2 {
            border: 1px solid green;
        }
    </style>
</head>
<body>
    <div class="c1"></div>
    <div class="c2"></div>
    <div class="c"></div>
    <div class="c1"></div>

<script>
    /*
    * 如果使用exec将一个字符串中所有的符合要求的内容找出来
    *
    * 1. 正则对象需要提前设置
    * 2. 全局匹配
    * 3.多次exec 即可
    * */

    var r = /\d/g;
    var str = '12344';
    var m = r.exec(str);
    console.log(m[0]); // 1
    m = r.exec(str);
    console.log(m[0]); // 2


    //replace
    var s = '123';
    var st = s.replace(/\d/, 'a'); // a23
    console.log(st);
    st = s.replace(/\d/g, 'b'); // abb
    console.log(st); // bbb

    // notice: exec, 每次只是匹配一次。 而 replace 是有多少匹配多少， 前提是 g

    //另外注意 \d+
    st = s.replace(/\d+/, 'c');
    console.log(st); // c, 是整体换为 c


    // 实现 getElementsByClassNames
    var getEleByClassName = function (className, results) {
        results = results || [];
        var tempArr, i;
        // 首先判断系统所提供的方法是否可以实现该功能
        if (document.getElementsByClassName) {
            results.push.apply(results, document.getElementsByClassName(className));

        } else {
        // 自定义实现
         /*
         * 思路，
         * 首先获得所有的元素，然后在元素中索索符合要求的元素，再加入到数组中
         * */
         tempArr = document.getElementsByTagName("*");
//            for 循环，判断是否符合要求
            for (i = 0; i < tempArr.length; i++) {

                // 兼容className, 或者是 getAttribute, 主要是 考虑  xml
                if ( (' ' + tempArr[i].className + ' ').indexOf(' ' + className + ' ') != -1 ) {  // 看看是否包含这个className
                    results.push(tempArr[i]);
                }
            }

        }
        return results;
    };
    
    // 验证
    var list = getEleByClassName('c1');
    list[0].style.backgroundColor = 'yellow';
    for (var k in list) {
        list[k].style.backgroundColor = 'pink';
    }


    // IE 8 push 方法的兼容问题
    var myPush = function (target, els) {
        var j = target.length,
            i = 0;
        // cannot trust nodeList.length
        while ((target[j++] = els[i++])) {}
        target.length = j - 1;
    };

    // 因此对 getTag 方法进行修改
    var getTag = function (tag, results) {
        results = results || [];
        try {
            results.push.apply(results, document.getElementsByTagName(tag));
        } catch (e) {
            myPush(results, document.getElementsByTagName(tag));
        }

//        push.apply(....);
        return results;
    };

    var each = function (arr, fn) {
        for (var i = 0; i < arr.length; i++) {
            if (fn.call(arr[i], i, arr[i]) === false) {
                break;
            }
        }
    };

    /*
    * 优化 push方法的思路
    *
    * 我么直接将 try 写到外面
    * var push = [].push;
    * try {
    *   push 可用
    * } catch (e) {
    *   push = {...}
    * }
    *
    * 然后我只需要 调用 push 方法即可, 这个在 沙箱里面是全局的，不是 support
    *
    * */


    /*
    *
    * 原生字符串方法
    *
    * if (selector) === '*' return;
    *
    * var firstChar = selector.charAt(0);
    * witch (firstChar) {
    *   case '#': selector.slice(1); break;
    *   case '.': break;
    *   default: break;
    *
    * }
    *
    *
    * */




</script>
</body>
</html>












































